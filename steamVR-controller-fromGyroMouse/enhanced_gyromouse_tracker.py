#!/usr/bin/env python3
"""
Enhanced GyroMouse Tracker
- Tracks mouse cursor movement for position
- Uses gyro data for rotation (simulated for now)
- ArUco markers for calibration
- Supports left/right hand controllers
"""

import socket
import struct
import time
import math
import threading
import numpy as np
from scipy.spatial.transform import Rotation

# Try to import libraries
try:
    import cv2
    OPENCV_AVAILABLE = True
except ImportError:
    OPENCV_AVAILABLE = False
    print("Warning: OpenCV not available, ArUco tracking disabled")

try:
    import win32gui
    import win32api
    WINDOWS_API_AVAILABLE = True
except ImportError:
    WINDOWS_API_AVAILABLE = False
    print("Warning: pywin32 not available, using basic mouse tracking")

try:
    import hid
    HID_AVAILABLE = True
except ImportError:
    HID_AVAILABLE = False
    print("Warning: hidapi not available, using simulated gyro")


class MouseTracker:
    """Track mouse cursor movement and convert to VR controller position"""
    
    def __init__(self, sensitivity=0.001, center_x=None, center_y=None):
        self.sensitivity = sensitivity
        self.last_mouse_x = 0
        self.last_mouse_y = 0
        self.position = np.array([-0.2, 1.0, -0.5])  # Default left hand position
        self.position_lock = threading.Lock()
        
        # Get screen center
        if WINDOWS_API_AVAILABLE:
            screen_width = win32api.GetSystemMetrics(0)
            screen_height = win32api.GetSystemMetrics(1)
            self.center_x = center_x or screen_width // 2
            self.center_y = center_y or screen_height // 2
        else:
            self.center_x = center_x or 960
            self.center_y = center_y or 540
        
        print(f"Mouse tracking center: ({self.center_x}, {self.center_y})\")\n    \n    def update_from_mouse(self):\n        \"\"\"Update position from mouse cursor\"\"\"\n        if WINDOWS_API_AVAILABLE:\n            try:\n                cursor_pos = win32gui.GetCursorPos()\n                mouse_x, mouse_y = cursor_pos\n            except:\n                return False\n        else:\n            # Fallback - use time-based simulation\n            t = time.time()\n            mouse_x = self.center_x + math.sin(t * 0.5) * 200\n            mouse_y = self.center_y + math.cos(t * 0.3) * 150\n        \n        # Calculate delta from center\n        delta_x = (mouse_x - self.center_x) * self.sensitivity\n        delta_y = (mouse_y - self.center_y) * self.sensitivity\n        \n        # Convert to VR space\n        # Mouse X -> VR X (left/right)\n        # Mouse Y -> VR Z (forward/back, inverted)\n        # VR Y stays constant (height)\n        \n        with self.position_lock:\n            self.position[0] = -0.2 + delta_x  # Left hand base + mouse movement\n            self.position[1] = 1.0 - delta_y * 0.5  # Slight height variation\n            self.position[2] = -0.5 - delta_y  # Forward/back movement\n            \n            # Clamp to reasonable bounds\n            self.position[0] = np.clip(self.position[0], -1.0, 1.0)\n            self.position[1] = np.clip(self.position[1], 0.5, 1.5)\n            self.position[2] = np.clip(self.position[2], -1.5, 0.5)\n        \n        return True\n    \n    def get_position(self):\n        \"\"\"Get current position\"\"\"\n        with self.position_lock:\n            return self.position.copy()\n    \n    def recenter(self):\n        \"\"\"Reset to center position\"\"\"\n        with self.position_lock:\n            self.position = np.array([-0.2, 1.0, -0.5])\n\n\nclass GyroSimulator:\n    \"\"\"Simulate gyroscope data or read from real device\"\"\"\n    \n    def __init__(self, vendor_id=0x2389, product_id=0x00a8):\n        self.vendor_id = vendor_id\n        self.product_id = product_id\n        self.device = None\n        self.rotation = Rotation.from_quat([0, 0, 0, 1])  # Identity\n        self.rotation_lock = threading.Lock()\n        self.gyro_data = [0.0, 0.0, 0.0]\n        \n        # Try to open HID device\n        if HID_AVAILABLE:\n            self.open_device()\n    \n    def open_device(self):\n        \"\"\"Try to open the gyro mouse HID device\"\"\"\n        try:\n            self.device = hid.device()\n            self.device.open(self.vendor_id, self.product_id)\n            self.device.set_nonblocking(True)\n            print(f\"Opened gyro mouse: {self.vendor_id:04x}:{self.product_id:04x}\")\n            return True\n        except Exception as e:\n            print(f\"Could not open gyro mouse: {e}\")\n            self.device = None\n            return False\n    \n    def update_rotation(self, dt):\n        \"\"\"Update rotation from gyro data\"\"\"\n        if self.device:\n            # Try to read real gyro data\n            gyro_x, gyro_y, gyro_z = self.read_real_gyro()\n        else:\n            # Use simulated gyro data\n            gyro_x, gyro_y, gyro_z = self.simulate_gyro()\n        \n        # Store for UDP transmission\n        self.gyro_data = [gyro_x, gyro_y, gyro_z]\n        \n        # Integrate angular velocity to rotation\n        angular_speed = math.sqrt(gyro_x**2 + gyro_y**2 + gyro_z**2)\n        if angular_speed > 0.1:  # Threshold to avoid noise\n            axis = np.array([gyro_x, gyro_y, gyro_z]) / angular_speed\n            angle = math.radians(angular_speed) * dt\n            delta_rotation = Rotation.from_rotvec(axis * angle)\n            \n            with self.rotation_lock:\n                self.rotation = delta_rotation * self.rotation\n    \n    def read_real_gyro(self):\n        \"\"\"Read gyroscope data from HID device\"\"\"\n        try:\n            data = self.device.read(64)\n            if data and len(data) >= 16:\n                # Parse gyro data - format depends on your specific mouse!\n                # This is a generic example, adjust for your device\n                gyro_x = struct.unpack('<h', bytes(data[10:12]))[0] / 32768.0 * 500\n                gyro_y = struct.unpack('<h', bytes(data[12:14]))[0] / 32768.0 * 500\n                gyro_z = struct.unpack('<h', bytes(data[14:16]))[0] / 32768.0 * 500\n                return gyro_x, gyro_y, gyro_z\n        except Exception as e:\n            pass\n        \n        return 0.0, 0.0, 0.0\n    \n    def simulate_gyro(self):\n        \"\"\"Simulate gyroscope data for testing\"\"\"\n        t = time.time()\n        return (\n            math.sin(t * 0.7) * 15,  # X rotation (degrees/sec)\n            math.cos(t * 0.5) * 20,  # Y rotation\n            math.sin(t * 0.3) * 10   # Z rotation\n        )\n    \n    def get_quaternion(self):\n        \"\"\"Get current rotation as quaternion (w, x, y, z)\"\"\"\n        with self.rotation_lock:\n            quat = self.rotation.as_quat()  # [x, y, z, w]\n            return quat[3], quat[0], quat[1], quat[2]  # w, x, y, z\n    \n    def get_gyro_data(self):\n        \"\"\"Get current gyro data for UDP\"\"\"\n        return self.gyro_data.copy()\n    \n    def close(self):\n        if self.device:\n            self.device.close()\n\n\nclass ArUcoCalibrator:\n    \"\"\"ArUco marker tracking for position calibration\"\"\"\n    \n    def __init__(self, camera_index=0):\n        self.camera = None\n        self.calibration_position = None\n        self.calibration_lock = threading.Lock()\n        \n        if OPENCV_AVAILABLE:\n            self.setup_camera(camera_index)\n    \n    def setup_camera(self, camera_index):\n        \"\"\"Setup camera for ArUco tracking\"\"\"\n        try:\n            self.camera = cv2.VideoCapture(camera_index)\n            self.camera.set(cv2.CAP_PROP_FRAME_WIDTH, 640)\n            self.camera.set(cv2.CAP_PROP_FRAME_HEIGHT, 480)\n            \n            # ArUco setup\n            self.aruco_dict = cv2.aruco.getPredefinedDictionary(cv2.aruco.DICT_4X4_50)\n            self.aruco_params = cv2.aruco.DetectorParameters()\n            self.detector = cv2.aruco.ArucoDetector(self.aruco_dict, self.aruco_params)\n            \n            # Camera calibration (approximate values)\n            self.camera_matrix = np.array([\n                [800, 0, 320],\n                [0, 800, 240],\n                [0, 0, 1]\n            ], dtype=float)\n            self.dist_coeffs = np.zeros((4, 1))\n            self.marker_size = 0.05  # 5cm markers\n            \n            print(\"ArUco calibration system ready\")\n            return True\n        except Exception as e:\n            print(f\"Could not setup camera: {e}\")\n            return False\n    \n    def calibrate_position(self, marker_id=0):\n        \"\"\"Calibrate position using ArUco marker\"\"\"\n        if not self.camera:\n            return False\n        \n        ret, frame = self.camera.read()\n        if not ret:\n            return False\n        \n        corners, ids, _ = self.detector.detectMarkers(frame)\n        \n        if ids is not None and marker_id in ids:\n            idx = np.where(ids == marker_id)[0][0]\n            \n            # Estimate pose\n            rvecs, tvecs, _ = cv2.aruco.estimatePoseSingleMarkers(\n                [corners[idx]], self.marker_size,\n                self.camera_matrix, self.dist_coeffs\n            )\n            \n            # Convert to SteamVR coordinates\n            tvec = tvecs[0][0]\n            position = np.array([\n                tvec[0],   # X\n                -tvec[1],  # Y (flip)\n                -tvec[2]   # Z (flip)\n            ])\n            \n            with self.calibration_lock:\n                self.calibration_position = position\n            \n            # Draw marker\n            cv2.aruco.drawDetectedMarkers(frame, corners, ids)\n            cv2.drawFrameAxes(frame, self.camera_matrix, self.dist_coeffs,\n                            rvecs[0], tvecs[0], 0.03)\n            \n            cv2.imshow('ArUco Calibration', frame)\n            cv2.waitKey(1)\n            return True\n        \n        cv2.imshow('ArUco Calibration', frame)\n        cv2.waitKey(1)\n        return False\n    \n    def get_calibration(self):\n        \"\"\"Get calibrated position\"\"\"\n        with self.calibration_lock:\n            return self.calibration_position.copy() if self.calibration_position is not None else None\n    \n    def close(self):\n        if self.camera:\n            self.camera.release()\n        cv2.destroyAllWindows()\n\n\nclass UDPSender:\n    \"\"\"Send controller data via UDP\"\"\"\n    \n    def __init__(self, host='127.0.0.1', port=5556):\n        self.host = host\n        self.port = port\n        self.sock = socket.socket(socket.AF_INET, socket.SOCK_DGRAM)\n        self.packet_number = 0\n    \n    def send_controller_data(self, controller_id, quat, position, gyro, buttons):\n        \"\"\"Send controller data packet\"\"\"\n        # Pack data: controller_id(1) + packet_num(4) + quat(16) + pos(12) + gyro(12) + buttons(2) + checksum(1)\n        data = struct.pack('<BI4f3f3fHB',\n            controller_id,\n            self.packet_number,\n            quat[0], quat[1], quat[2], quat[3],  # w, x, y, z\n            position[0], position[1], position[2],\n            gyro[0], gyro[1], gyro[2],\n            buttons,\n            0  # checksum placeholder\n        )\n        \n        # Calculate checksum\n        checksum = sum(data[:-1]) & 0xFF\n        data = data[:-1] + struct.pack('B', checksum)\n        \n        self.sock.sendto(data, (self.host, self.port))\n        self.packet_number += 1\n\n\ndef main():\n    print(\"=\" * 60)\n    print(\"Enhanced GyroMouse Tracker for SteamVR\")\n    print(\"=\" * 60)\n    print()\n    print(\"Features:\")\n    print(\"- Mouse cursor movement -> Controller position\")\n    print(\"- Gyroscope data -> Controller rotation\")\n    print(\"- ArUco markers -> Position calibration\")\n    print()\n    print(\"Controls:\")\n    print(\"- Move mouse to control position\")\n    print(\"- Press 'c' to calibrate with ArUco marker\")\n    print(\"- Press 'r' to recenter position\")\n    print(\"- Press Ctrl+C to quit\")\n    print()\n    \n    # Initialize components\n    mouse_tracker = MouseTracker(sensitivity=0.002)\n    gyro_sim = GyroSimulator()\n    aruco_cal = ArUcoCalibrator()\n    udp_sender = UDPSender()\n    \n    # Calibration thread\n    def calibration_thread():\n        while running:\n            if OPENCV_AVAILABLE:\n                aruco_cal.calibrate_position(marker_id=0)\n            time.sleep(0.033)  # 30 FPS\n    \n    running = True\n    if OPENCV_AVAILABLE:\n        cal_thread = threading.Thread(target=calibration_thread, daemon=True)\n        cal_thread.start()\n    \n    try:\n        last_time = time.time()\n        \n        while True:\n            now = time.time()\n            dt = now - last_time\n            last_time = now\n            \n            # Update mouse position\n            mouse_tracker.update_from_mouse()\n            position = mouse_tracker.get_position()\n            \n            # Update gyro rotation\n            gyro_sim.update_rotation(dt)\n            quat = gyro_sim.get_quaternion()\n            gyro_data = gyro_sim.get_gyro_data()\n            \n            # Check for ArUco calibration\n            calibration = aruco_cal.get_calibration()\n            if calibration is not None:\n                # Use ArUco position instead of mouse position\n                position = calibration\n            \n            # Send data (controller_id=0 for left hand)\n            buttons = 0  # No buttons for now\n            udp_sender.send_controller_data(0, quat, position, gyro_data, buttons)\n            \n            # Status output\n            if udp_sender.packet_number % 120 == 0:  # Every 2 seconds at 60fps\n                cal_status = \"CALIBRATED\" if calibration is not None else \"MOUSE\"\n                print(f\"[{cal_status}] Pos({position[0]:.2f}, {position[1]:.2f}, {position[2]:.2f}) \"\n                      f\"Quat({quat[0]:.2f}, {quat[1]:.2f}, {quat[2]:.2f}, {quat[3]:.2f})\")\n            \n            time.sleep(0.016)  # ~60 FPS\n    \n    except KeyboardInterrupt:\n        print(\"\\nShutting down...\")\n    finally:\n        running = False\n        gyro_sim.close()\n        aruco_cal.close()\n        print(\"Done!\")\n\n\nif __name__ == \"__main__\":\n    main()